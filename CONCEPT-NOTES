CONCEPT NOTES

TRANSITION:
-You use transition on the element/s that's going to change in the future
-From what I can tell, you can also specify which specific attributes you want it to transition on, so for for example, you can tell it to only transition on the width or height. I still don't know how it works if you don't specify anything at all.
  I just tested the above concept, and it's very powerful because you can basically have each attribute transition at different times.
  NOTE: In order to have different attributes transition at different times, you need to separate them with a comma.
    EXAMPLE:
      .my-class{
        transition: width 2s, height 5s;
      }
-I'm not sure about this, but it seems that transition doesn't work on the position attribute. I don'
t know why, or if there's another way to make it work, but so far, it's not working

Transition Timing Function: You remember this one right? This one determines the actual effects of the transition as far as slowing down or speeding up. Here are the different options.
  Just like the transition, this attribute applies to the selector where the change is going to take place, before it takes place.
  -ease: slow start, fast end (default)
  -linear: same consistent speed
  -ease-in: slow start
  -ease-out: slow end
  -ease-in-out: slow start and end
  -cubic bezier: define your own values in a cubic bezier. I don't understand how the values work, or how to manipulate them. I need to study this particular topic a lot more

-I've learned about a few things when it comes to cubic beziers. This info is still fairly speculative.
  -So first, it always has to end in 1, which means if you wanted to create the bouncy effect, you'd need to make the last number higher than 1, and so what this is going to do, is go past it, and come back to the one.
  -Another thing that I believe I learned is that, when you unhover, it eventually has to come back to normal, so it has to follow the same process, in reverse. I'm still fuzzy on all the details but I think this is kinda how it works.
  -Ok, this is weird and I still don't fully understand it. Basically if the values go in order from smaller to greater, it just goes linearly, even if you have negative values which is weird because they're supposed to go past their starting and ending point which is 0 and 1,
    however, if you want it to create the bouncy effect, then you have to get the first value to greater than the second one, and then the last value is going to work like that. Otherwise, none of them are gonna work.

OVERVIEW: I learned the syntax, and overall how to use it, but it's still unpredictable to me, and I guess I still don't understand the concept of bezier curves, I definitely need to come back to bezier curves, but I decided to put it on the back burner, because my time can be used more efficiently elsewhere.


--------------------------------------------

ES5 BINDING THIS KEYWORD

THE PURPOSE OF BINDING: Ok so what I'm noticing is that you use binding sort of as a portal to reference things that you normally wouldn't be able to reference, for example if you want to reference an attribute inside of an object, from within that same object. So far I'm studying implicit binding. It's also a way to make sure js doesn't get confused when referencing things if there are properties that are alike, etc.

Implicit Binding Deep-dive
-First of all, where you use the this is where you reference it, but it doesn't know what this is going to be yet, until you tell it. You're basically saying, whatever piece of data that's going to show up that contains said property name (the name after the this keyword like: this.name), apply to that property inside that piece of data.
-Now the way that js knows that "this" is going to be, is when you invoke it, what ever is to the left of the dot. At that point, js simply replaces the "this" keyword, with the name of the data that got invoked


////////////////////////////////////////////////////////
MISC NOTES
-Function inside an object literal: When you put a function inside an object literal, you either have to define it within the object literal, or otherwise if you want to reference an external function, you need to make sure you do not include the parenthesis, otherwise it's going to call it immediately, and you won't be able to refer to it at a later time. 









.
