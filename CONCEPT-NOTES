CONCEPT NOTES

TRANSITION:
-You use transition on the element/s that's going to change in the future
-From what I can tell, you can also specify which specific attributes you want it to transition on, so for for example, you can tell it to only transition on the width or height. I still don't know how it works if you don't specify anything at all.
  I just tested the above concept, and it's very powerful because you can basically have each attribute transition at different times.
  NOTE: In order to have different attributes transition at different times, you need to separate them with a comma.
    EXAMPLE:
      .my-class{
        transition: width 2s, height 5s;
      }
-I'm not sure about this, but it seems that transition doesn't work on the position attribute. I don'
t know why, or if there's another way to make it work, but so far, it's not working

Transition Timing Function: You remember this one right? This one determines the actual effects of the transition as far as slowing down or speeding up. Here are the different options.
  Just like the transition, this attribute applies to the selector where the change is going to take place, before it takes place.
  -ease: slow start, fast end (default)
  -linear: same consistent speed
  -ease-in: slow start
  -ease-out: slow end
  -ease-in-out: slow start and end
  -cubic bezier: define your own values in a cubic bezier. I don't understand how the values work, or how to manipulate them. I need to study this particular topic a lot more

-I've learned about a few things when it comes to cubic beziers. This info is still fairly speculative.
  -So first, it always has to end in 1, which means if you wanted to create the bouncy effect, you'd need to make the last number higher than 1, and so what this is going to do, is go past it, and come back to the one.
  -Another thing that I believe I learned is that, when you unhover, it eventually has to come back to normal, so it has to follow the same process, in reverse. I'm still fuzzy on all the details but I think this is kinda how it works.
  -Ok, this is weird and I still don't fully understand it. Basically if the values go in order from smaller to greater, it just goes linearly, even if you have negative values which is weird because they're supposed to go past their starting and ending point which is 0 and 1,
    however, if you want it to create the bouncy effect, then you have to get the first value to greater than the second one, and then the last value is going to work like that. Otherwise, none of them are gonna work.

OVERVIEW: I learned the syntax, and overall how to use it, but it's still unpredictable to me, and I guess I still don't understand the concept of bezier curves, I definitely need to come back to bezier curves, but I decided to put it on the back burner, because my time can be used more efficiently elsewhere.


--------------------------------------------

                      ES5 BINDING THIS KEYWORD

THE PURPOSE OF BINDING: Ok so what I'm noticing is that you use binding sort of as a portal to reference things that you normally wouldn't be able to reference, for example if you want to reference an attribute inside of an object, from within that same object. So far I'm studying implicit binding. It's also a way to make sure js doesn't get confused when referencing things if there are properties that are alike, etc.

IMPLICIT BINDING DEEP-DIVE
-First of all, where you use the this is where you reference it, but it doesn't know what this is going to be yet, until you tell it. You're basically saying, whatever piece of data that's going to show up that contains said property name (the name after the this keyword like: this.name), apply to that property inside that piece of data.
-Now the way that js knows that "this" is going to be, is when you invoke it, what ever is to the left of the dot. At that point, js simply replaces the "this" keyword, with the name of the data that got invoked

-I just discovered something really cool about functions!: When you create a function with a parameter, and then you invoke(call) that function, but instead of filling in the string value to take the place of the parameter, you put in an existing object, or data. Instead of simply executing that function, it'll actually pass in that piece of data. This is amazing, because then you can dynamically manipulate that data from within the function. For example, you can pass in a new property to what ever object is put into the function and of course you can invoke this function with multiple different objects
  FULL EXAMPLE:
    function nameCreator(newName){
      newName.nameCaller = function(){
        return `My name is ${this.name}`
      }
    }

    NOTE: The function above passes in a parameter which is going to be an object. Once we invoke this function with a pre-made object, it's going to pass in that object, and execute whatever is inside it. In this case, it's going to create a new attribute called nameCaller to that object.
      CODE:
        let myName = {
          name: "Jazzy"
        }

        nameCreator(myName)

    NOTE: In this example right above, by invoking it, we told it to pass in the object called myName and furthermore, to create an attribute inside of myName called nameCaller. So now when we call myName.nameCaller(), it's going to execute the anonymous function inside of nameCaller. Here it is again
      CODE
        myName.nameCaller();

    NOTE: The code above will execute the anonymous function, which is going to return that message, but here comes the key. Because myName is what's to the left of the dot when the function containing this.name got invoked. "this" is going to be replaced with myName. And so the "this" keyword, will look for the property called name, and return it's value which in this case is "Jazzy"
      FINAL RESULTS:
        "My name is Jazzy"

Final Example:
  function people(name, last){
    return {
      name: name,
      last: last,
      sayName: function(){
        return `Yo, I'm ${this.name}`
      }
    }
  }

  let jazzy = people("Jazzy", "Vazquez");

  NOTE: So in this example above, we stored the function call inside jazzy, so now the object is inside of the variable called jazzy, which means that when we call jazzy.sayName() it's going to invoke the anonymous function which once again is going to fire the "this" keyword, which is being invoked by the variable jazzy, or in other words by the function, and this is going to be replaced with the attribute called name, which lives inside of our function called people.
--------------------------------------------------------

EXPLICIT BINDING DEEP-DIVE
-Explicit binding seems to be a ton simpler than, implicit binding. Here the rules are simple.
-First of all, it's best to use this kind of binding, when you have a standalone or global function that you want to execute.
-You can use the "this" keyword inside the function.
-Then, you can use one of the binding methods which are the following: call(), apply(), bind()
  EXAMPLE:
    function myFunc(name){
      return `My name is ${name}. ${this.message}`
    }

    let me = {
      message: "Nice to meet you"
    }

  call() : Literally calls the function, and the first parameter you include in it is the context, or in other words, that's where the "this" keyword is going to look for the chosen property. All the following string parameters account for the function's original parameters.
    Example:
      myFunc.call(me, "Jazzy")

  apply() : Does the exact same thing as call, except that instead of using strings as parameters, following the initial parameter which gives it the context, make an array of the other parameters the function originally contains.
    Example:
      myFunc.apply(me, ["Jazzy"])


////////////////////////////////////////////////////////
MISC NOTES
-Function inside an object literal: When you put a function inside an object literal, you either have to define it within the object literal, or otherwise if you want to reference an external function, you need to make sure you do not include the parenthesis, otherwise it's going to call it immediately, and you won't be able to refer to it at a later time.













.
